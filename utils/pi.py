pi_ref ="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904"

digits = 512
columns = 10 * digits
denominator = [10] + [ (i*2)+1 for i in range (1,columns) ]
rem = [2] * columns
mypi = []

for j in range(0,digits):
    q = 0
    for i in range(columns-1,-1,-1):
        n = q * (i+1) + (rem[i] * 10)
        rem[i] = n % denominator[i]
        q = n // denominator[i]

    ## Normally end up with a q in range 0..9 but if value is 10 then need to
    ## correct the previous digit ... and keep going if correcting that sets it
    ## to 10 and so on ...
    i = len(mypi)-1
    correction=q
    while correction==10:
        correction = mypi[i]+1
        if correction == 10:
            mypi[i] = 0
        else:
            mypi[i] = correction
        i-=1
    ## Finally append the new digit
    mypi.append(q%10)

pi_str = ["%d" % c for c in mypi]
pi_str[1:1]='.'    
errors = 0
for i in range(0,digits):
    if pi_str[i] != pi_ref[i]:
        errors += 1
        print("Error at digit %d: reference: %s computed: %s" % ( i, pi_ref[i], pi_str[i]))

if errors == 0:
    print("PASS all %d digits match!" % digits)

print( ''.join(pi_str))

